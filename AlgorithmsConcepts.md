# Algorithmic concepts

### Algorithm(알고리즘) 
- 문제가 주어졌을때, 알고리즘은 한정된 시간과 공간에서 실행되는 잘 정의된 명령어 집합. 입력을 수신하고 문제의 제약 조건을 만족시키는 출력을 반환

- I -> Algorithms -> O

### Iteration(반복) 
- 반복 알고리즘은 일련의 동작을 통해 실행되는 알고리즘, 잠시 동안이 특징
- 주어진 목록의 모든 요소의 합계를 반환한다고 가정
- 예) 목록의 각 요소를 변수에 순차적으로 추가하고 최종 값을 반환

### Recursion(재귀)
- 재귀 알고리즘은 자신을 호출하는 함수 사용 
- 기본 케이스 : 출력이 알려진 입력 집합
- 재귀 공식 : 현재 단계의 답은 이전 단계에 의존한 기능 호출을 기반으로 기본 사례 답을 이용

- 재귀함수를 사용하는 알고리즘(부록)
- 고전적인 문제는 명백하게 power operation 을 배제하고 숫자를 계산한다.

### Call Stack
- 재귀 알고리즘으로, 함수 호출에 사용되는 공간을 스택 공간이라고 한다.

### Stack overflow (스택포인터가 스택의 경계를 넘어설 때)
- 스택오버플로 문제는 재귀 알고리즘이 허용된 최대 스택 공간보다 더 많은 스택공간을 사용할 때 발생

- 병목 현상을 피하기 위한 해결책은 코드를 재귀적 코드에서 반복적인 코드로 변환하여 다음 코드에 의존
스택보다 메모리가 커질 경우

### Memoization (DP 동적 계획법 알고리즘에서 핵심이 되는 기술)
- 메모화는 반복되는 함수 호출의 결과를 저장함으로써 런타임의 속도를 높이는 것을 목표로 하는 최적화 기법
- 동일한 결과가 필요할 때 캐시를 반환

# Types of algorithms

### Brute force
- Brute force 접근법은 문제의 가능한 모든 출력 후보를 나열하고 그 중 하나가 있는지 확인하는 것을 목표로 한다. 
- 제약 조건을 충족, 일반적으로 문제를 해결하는 가장 비효율적인 방법
- 이 기법을 설명하기 위해 다음 문제를 고려해본다: 정렬된 배열이 주어지면, 주어진 숫자의 합이 되는 원소들의 모든 쌍을 반환하고자 한다.
- brute force 접근법은 가능한 모든 쌍을 시도하고 그 수에 합 한 쌍을 반환
- 원하는 결과를 생성하지만 최소 시간 내에 생성되지 않음

### Backtracking
- 백트래킹 알고리즘은 재귀적으로 잠재적인 해결책을 생성하고 문제를 만족시키지 못하는 해결책을 제거
- 제약, 무효 후보를 최대한 빨리 폐기하는 브루트 보스 버전으로 볼 수 있다.
- N-Queens 문제는 체스판에서 다음이 없는 퀸의 구성을 찾는 것을 목표
- 두 여왕은 서로를 공격한다. 역추적 접근 방식은 퀸을 한 번에 하나씩 배치하고 솔루션을 제거하는 것으로 구성

### Greedy
- 탐욕 알고리즘은 주어진 모든 단계에서 바로 최적의 것으로 보이는 선택을 한다.
- 주의할점은 결과 솔루션이 전체적으로 최적이 아닐 수 있다. 이 기술은 비교적 낮은 복잡도 알고리즘에 문제 범위에서 잘 해결된다.
- 주어진 시작점에서 가장 긴 경로를 가중치에서 찾는 문제를 고려
- 탐욕스러운 접근 방식은 가중치가 가장 높은 다음 에지를 반복적으로 선택하여 최종 경로를 구성
- 그 결과 솔루션은 낮은 가중치 에지 뒤에 "숨겨진" 큰 에지 가중치가 있는 더 긴 경로를 놓칠 수 있음

### Divide and conquer (분할 정복 알고리즘)
- 문제를 독립적으로 재귀적 분할을 통해 문제의 최종 결정을 계산
- 분할 : 이 문제는 몇 가지 독립적인 하위 문제로 나뉜다.
- 정복 : 각 하위 문제는 독립적으로 해결함
- 결합: 각 하위 문제의 결과를 결합하여 최종 답을 찾음
- 병합 정렬과 빠른 정렬과 같은 정렬 알고리즘을 포함

### Dynamic Programming
- 동적 프로그래밍(DP)은 겹치는 하위 문제에 대한 답을 찾는 문제 해결 방법이다.
- DP를 사용한 문제 해결의 일반적인 예는 피보나치 수의 계산이다.
- 두 가지 주요 접근 방식 존재
- Top-down 방식은 이전 값을 재귀적으로 계산하여 목표 값을 찾는다.
    - 1단계: 원하는 값을 계산하고 이전 값을 기반으로 합니다.
    - 2단계: 이전 값에 의존하는 이전 값을 계산 일부 값은 이미 계산되었을 수 있습니다. 이 경우 중복 작업을 방지하기 위해 메모화를 사용할 수 있습니다.
    - 3단계: 새로 계산된 값을 사용하여 추론
- Bottom-up 이미 알려진 결과에서 시작하여 다음 목표치 값에 도달할 때까지 반복적으로 다음 값을 계산한다.
    - 1단계: 미리 정해진 방법 등을 계산합니다. 이러한 값은 일반적으로 배열에 저장됩니다.
    - 2단계: 추론
- 요약하면, DP 문제로 해결하는 두 가지 주요 방법은 다음과 같다.


### 복잡성
- 정의
- 복잡성의 개념은 알고리즘의 효율성을 정량화하는 데 사용된다. 복잡성에는 두 가지 유형이 있습니다.
- 시간 : 얼마나 많은 작업을 수행합니까?
- 공간 : 추가 공간이 얼마나 필요합니까?
- 일반적으로 두 측정값 모두 입력 크기의 함수로 제공되지만 다른 파라미터도 사용할 수 있습니다.

### Notations 표기
- 알고리즘의 복잡성은 표에 설명된 표기와 함께 알려진 함수를 사용하여 설명될 수 있다.

### Master theorem 마스터 정리
- 마스터 정리는 아래 형식의 재귀 관계를 만족시키는 런타임의 명시적 해를 제공

### Problem Complexity 문제 복잡성
- 문제는 해결하는 것이 얼마나 어려운지 정량화하는 클래스와 제안된 솔루션이 있는지 확인하는 클래스로 나눌 수 있다.
- 잘 알려진 두 가지 클래스를 보여준다.
- 만약 다항식 시간에 해법을 찾는 것이 가능하다면, 다항식에서의 후보 검증이 가능하면 시간을 단축할 수 있다.
- 다항식 시간에 해결책을 검증할 수 있다는 것이 우리가 문제를 해결할 수 있다는 것을 의미하는지 확실하지 않다.
- 다항식을 일반적인 의견의 일치를 보았지만 이는 공식적으로 증명되지 않았다.
- NP의 모든 문제는 다항식 시간에 다음과 같은 문제 집합으로 축소될 수 있다.
     - NP-hard problems : 적어도 NP 문제만큼 어려운 NP-난해 문제
     - NP-complete problems : NP-완전 문제